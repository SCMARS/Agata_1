import os
import json
import asyncio
import logging
import httpx
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List, Set
from dataclasses import dataclass, field
from collections import defaultdict
import traceback

# –ò–º–ø–æ—Ä—Ç—ã —Å fallback
try:
    import telegram
    from telegram import Update, BotCommand
    from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
    TELEGRAM_AVAILABLE = True
except ImportError:
    TELEGRAM_AVAILABLE = False
    print("‚ö†Ô∏è python-telegram-bot not installed. Install with: pip install python-telegram-bot")


@dataclass
class BotConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞ –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
    token: str
    timeout: int = 30
    connection_pool_size: int = 8
    allowed_users: Set[int] = field(default_factory=set)
    admin_users: Set[int] = field(default_factory=set)
    max_message_length: int = 4096
    rate_limit_messages_per_minute: int = 20
    rate_limit_commands_per_hour: int = 100
    commands: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    messages: Dict[str, str] = field(default_factory=dict)
    memory_integration: Dict[str, Any] = field(default_factory=dict)
    logging_config: Dict[str, Any] = field(default_factory=dict)


class ProductionTelegramBot:
    """Production-ready Telegram Bot –±–µ–∑ —Ö–∞—Ä–¥–∫–æ–¥–∞"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.config = None
        self.application = None
        self.rate_limiter = defaultdict(list)

        self.api_base_url = os.getenv("API_BASE_URL", "http://localhost:8000")
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        self._load_config()
        
        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        self._setup_logging()
        
        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –±–æ—Ç–∞
        self._setup_bot()
    
    def _load_config(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –±–æ—Ç–∞"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
            token = os.getenv('TELEGRAM_BOT_TOKEN')
            if not token:
                raise ValueError("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
            
            # –ü–æ–ª—É—á–∞–µ–º –∞–¥–º–∏–Ω–æ–≤ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
            admin_users_str = os.getenv('BOT_ADMIN_USERS', '[]')
            try:
                admin_users = set(json.loads(admin_users_str))
            except json.JSONDecodeError:
                admin_users = set()
                print("‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: BOT_ADMIN_USERS –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
                print("üí° –î–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö –∫–æ–º–∞–Ω–¥ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ:")
                print("   export BOT_ADMIN_USERS='[123456789, 987654321]'")
                print("   (–∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à–∏ Telegram user ID)")
            
            self.config = BotConfig(
                token=token,
                allowed_users=set(),  # –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ = –≤—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
                admin_users=admin_users,
                commands={
                    "start": {"description": "–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –∏ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ", "enabled": True},
                    "help": {"description": "–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º", "enabled": True},
                    "memory": {"description": "–î–æ–±–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç—å", "enabled": True},
                    "search": {"description": "–ü–æ–∏—Å–∫ –≤ –ø–∞–º—è—Ç–∏", "enabled": True},
                    "overview": {"description": "–û–±–∑–æ—Ä –ø–∞–º—è—Ç–∏", "enabled": True},
                    "clear": {"description": "–û—á–∏—Å—Ç–∏—Ç—å –ø–∞–º—è—Ç—å", "enabled": True},
                    "test": {"description": "–¢–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏", "enabled": True},
                },
                messages={
                    "welcome": """ü§ñ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Agatha Memory Bot!

–Ø - –±–æ—Ç –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏ Agatha —Å LangChain –∏ LangGraph.

–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
‚Ä¢ /start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É
‚Ä¢ /help - –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º  
‚Ä¢ /memory - –î–æ–±–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç—å
‚Ä¢ /search <–∑–∞–ø—Ä–æ—Å> - –ü–æ–∏—Å–∫ –≤ –ø–∞–º—è—Ç–∏
‚Ä¢ /overview - –û–±–∑–æ—Ä –ø–∞–º—è—Ç–∏
‚Ä¢ /clear - –û—á–∏—Å—Ç–∏—Ç—å –ø–∞–º—è—Ç—å
‚Ä¢ /test - –¢–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏

–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:
1. –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ - –æ–Ω–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –ø–∞–º—è—Ç—å
2. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–º—è—Ç—å—é
3. –¢–µ—Å—Ç–∏—Ä—É–π—Ç–µ –ø–æ–∏—Å–∫ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç

–í–∞—à ID: {user_id}""",
                    "help": """üìñ –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:

/start - –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∏ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ
/help - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞
/memory <—Ç–µ–∫—Å—Ç> - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç –≤ –ø–∞–º—è—Ç—å
/search <–∑–∞–ø—Ä–æ—Å> - –Ω–∞–π—Ç–∏ –≤ –ø–∞–º—è—Ç–∏
/overview - –æ–±–∑–æ—Ä –ø–∞–º—è—Ç–∏
/clear - –æ—á–∏—Å—Ç–∏—Ç—å –ø–∞–º—è—Ç—å
/test - —Ç–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã

–í—Å–µ –æ–±—ã—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –ø–∞–º—è—Ç—å.""",
                    "unauthorized": "‚õî –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ",
                    "error_generic": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {error}",
                    "memory_saved": "‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –ø–∞–º—è—Ç—å",
                    "memory_error": "‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {error}",
                    "search_no_results": "üîç –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É: {query}",
                }
            )
            
            self.logger.info("Bot config loaded successfully. Admin users: %d", len(self.config.admin_users))
            
        except Exception as e:
            self.logger.error(f"Failed to load bot config: {e}")
            raise
    
    def _setup_logging(self):
        """–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ"""
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] %(name)s [%(levelname)s] %(message)s',
            handlers=[
                logging.FileHandler('telegram_bot.log'),
                logging.StreamHandler()
            ]
        )
        
        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–≥–µ—Ä telegram –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
        telegram_logger = logging.getLogger('telegram')
        telegram_logger.setLevel(logging.WARNING)  # –ú–µ–Ω—å—à–µ —Å–ø–∞–º–∞
    
    def _setup_bot(self):
        """–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç Telegram –±–æ—Ç–∞"""
        if not self.config:
            raise RuntimeError("Bot config not loaded")
        
        if not TELEGRAM_AVAILABLE:
            raise RuntimeError("Telegram library not available")
        
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        self.application = Application.builder().token(self.config.token).build()
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
        self.application.add_handler(CommandHandler("start", self._start_command))
        self.application.add_handler(CommandHandler("help", self._help_command))
        self.application.add_handler(CommandHandler("memory", self._memory_command))
        self.application.add_handler(CommandHandler("search", self._search_command))
        self.application.add_handler(CommandHandler("overview", self._overview_command))
        self.application.add_handler(CommandHandler("clear", self._clear_command))
        self.application.add_handler(CommandHandler("test", self._test_command))
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ–±—ã—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_message))
        
        self.logger.info("Telegram bot setup completed")
    
    async def _start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        user_id = update.effective_user.id
        welcome_msg = self.config.messages["welcome"].format(user_id=user_id)
        await update.message.reply_text(welcome_msg)
    
    async def _help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help"""
        await update.message.reply_text(self.config.messages["help"])
    
    async def _memory_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /memory"""
        user_id = update.effective_user.id
        text = ' '.join(context.args) if context.args else "–¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–∞–º—è—Ç–∏"
        
        try:
            async with httpx.AsyncClient(timeout=httpx.Timeout(60.0)) as client:
                response = await client.post(
                    f"{self.api_base_url}/api/memory/{user_id}/add",
                    json={"message": text, "role": "user"}
                )
                
            if response.status_code == 200:
                await update.message.reply_text(self.config.messages["memory_saved"])
            else:
                await update.message.reply_text(
                    self.config.messages["memory_error"].format(error=f"HTTP {response.status_code}")
                )
        except Exception as e:
            await update.message.reply_text(
                self.config.messages["memory_error"].format(error=str(e))
            )
    
    async def _search_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /search"""
        user_id = update.effective_user.id
        query = ' '.join(context.args) if context.args else "—Ç–µ—Å—Ç"
        
        try:
            async with httpx.AsyncClient(timeout=httpx.Timeout(60.0)) as client:
                response = await client.get(
                    f"{self.api_base_url}/api/memory/{user_id}/search",
                    params={"query": query, "limit": 5}
                )
                
            if response.status_code == 200:
                results = response.json()
                if results.get("results"):
                    message = "üîç –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞:\n\n"
                    for i, result in enumerate(results["results"][:3], 1):
                        message += f"{i}. {result['content'][:100]}...\n"
                    await update.message.reply_text(message)
                else:
                    await update.message.reply_text(
                        self.config.messages["search_no_results"].format(query=query)
                    )
            else:
                await update.message.reply_text(
                    self.config.messages["error_generic"].format(error=f"HTTP {response.status_code}")
                )
        except Exception as e:
            await update.message.reply_text(
                self.config.messages["error_generic"].format(error=str(e))
            )
    
    async def _overview_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /overview"""
        user_id = update.effective_user.id
        
        try:
            async with httpx.AsyncClient(timeout=httpx.Timeout(60.0)) as client:
                response = await client.get(f"{self.api_base_url}/api/memory/{user_id}/overview")
                
            if response.status_code == 200:
                overview = response.json()
                message = f"üìä –û–±–∑–æ—Ä –ø–∞–º—è—Ç–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}:\n\n"
                message += f"–ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞–º—è—Ç—å: {overview['overview']['levels']['short_term']['total_messages']} —Å–æ–æ–±—â–µ–Ω–∏–π\n"
                message += f"–î–æ–ª–≥–∞—è –ø–∞–º—è—Ç—å: {overview['overview']['levels']['long_term']['total_documents']} –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤\n"
                await update.message.reply_text(message)
            else:
                await update.message.reply_text(
                    self.config.messages["error_generic"].format(error=f"HTTP {response.status_code}")
                )
        except Exception as e:
            await update.message.reply_text(
                self.config.messages["error_generic"].format(error=str(e))
            )
    
    async def _clear_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /clear"""
        user_id = update.effective_user.id
        
        try:
            async with httpx.AsyncClient(timeout=httpx.Timeout(60.0)) as client:
                response = await client.post(f"{self.api_base_url}/api/memory/{user_id}/clear")
                
            if response.status_code == 200:
                await update.message.reply_text("‚úÖ –ü–∞–º—è—Ç—å –æ—á–∏—â–µ–Ω–∞")
            else:
                await update.message.reply_text(
                    self.config.messages["error_generic"].format(error=f"HTTP {response.status_code}")
                )
        except Exception as e:
            await update.message.reply_text(
                self.config.messages["error_generic"].format(error=str(e))
            )
    
    async def _test_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /test"""
        user_id = update.effective_user.id
        
        try:
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
            async with httpx.AsyncClient(timeout=httpx.Timeout(60.0)) as client:
                response = await client.post(
                    f"{self.api_base_url}/api/memory/{user_id}/add",
                    json={"message": f"–¢–µ—Å—Ç –æ—Ç {datetime.now().strftime('%H:%M:%S')}", "role": "user"}
                )
                
            if response.status_code == 200:
                await update.message.reply_text("‚úÖ –¢–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏ –ø—Ä–æ—à–µ–ª —É—Å–ø–µ—à–Ω–æ!")
            else:
                await update.message.reply_text(
                    self.config.messages["error_generic"].format(error=f"HTTP {response.status_code}")
                )
        except Exception as e:
            await update.message.reply_text(
                self.config.messages["error_generic"].format(error=str(e))
            )
    
    async def _handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        
        user_id = update.effective_user.id
        message_text = update.message.text
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º rate limiting
        if not self._check_rate_limit(user_id, "message"):
            await update.message.reply_text("‚è∞ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ.")
            return
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±—É—Ñ–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if not hasattr(self, 'user_message_buffers'):
            self.user_message_buffers = {}
        
        if user_id not in self.user_message_buffers:
            self.user_message_buffers[user_id] = {
                'messages': [],
                'last_message_time': None,
                'timer_task': None
            }
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –±—É—Ñ–µ—Ä
        current_time = datetime.now()
        self.user_message_buffers[user_id]['messages'].append({
            "role": "user", 
            "content": message_text,
            "timestamp": current_time
        })
        self.user_message_buffers[user_id]['last_message_time'] = current_time
        
        self.logger.info(f"üìù –î–æ–±–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –±—É—Ñ–µ—Ä –¥–ª—è {user_id}: '{message_text}'")
        self.logger.info(f"üìä –í—Å–µ–≥–æ –≤ –±—É—Ñ–µ—Ä–µ: {len(self.user_message_buffers[user_id]['messages'])} —Å–æ–æ–±—â–µ–Ω–∏–π")
        
        # –û—Ç–º–µ–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä, –µ—Å–ª–∏ –µ—Å—Ç—å
        if self.user_message_buffers[user_id]['timer_task']:
            self.user_message_buffers[user_id]['timer_task'].cancel()
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π —Ç–∞–π–º–µ—Ä –Ω–∞ 10 —Å–µ–∫—É–Ω–¥
        chat_id = update.effective_chat.id
        self.user_message_buffers[user_id]['chat_id'] = chat_id
        self.user_message_buffers[user_id]['timer_task'] = asyncio.create_task(
            self._process_buffered_messages(user_id)
        )
    
    async def _process_buffered_messages(self, user_id: int):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ—Å–ª–µ –∑–∞–¥–µ—Ä–∂–∫–∏"""
        try:
            # –ñ–¥–µ–º 10 —Å–µ–∫—É–Ω–¥
            await asyncio.sleep(10)
            
            if user_id not in self.user_message_buffers:
                return
            
            buffer = self.user_message_buffers[user_id]
            messages = buffer['messages']
            chat_id = buffer.get('chat_id')
            
            if not messages or not chat_id:
                return
            
            self.logger.info(f"‚è∞ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º {len(messages)} –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è {user_id}")
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç API
            async with httpx.AsyncClient(timeout=httpx.Timeout(60.0)) as client:
                response = await client.post(
                    f"{self.api_base_url}/api/chat",
                    json={
                        "user_id": str(user_id),
                        "messages": [{"role": msg["role"], "content": msg["content"]} for msg in messages]
                    }
                )
            
            self.logger.info(f"üì° Chat API –æ—Ç–≤–µ—Ç–∏–ª: {response.status_code}")
            
            if response.status_code == 200:
                chat_response = response.json()
                parts = chat_response.get("parts", [])
                delays_ms = chat_response.get("delays_ms", [])
                
                self.logger.info(f"üß† –ü–æ–ª—É—á–µ–Ω—ã —á–∞—Å—Ç–∏ –æ—Ç–≤–µ—Ç–∞: {len(parts)}")
                

                for i, part in enumerate(parts):
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –∏–∑ API –∏–ª–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é
                    delay = delays_ms[i] / 1000 if i < len(delays_ms) else 0.5
                    
                    if i > 0:
                        await asyncio.sleep(delay)
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ bot API
                    from telegram import Bot
                    bot = Bot(token=self.config.token)
                    await bot.send_message(
                        chat_id=chat_id,
                        text=part
                    )
                    self.logger.info(f"‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —á–∞—Å—Ç—å {i+1}: {part[:50]}...")
                
                # –û—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
                self.user_message_buffers[user_id]['messages'] = []
                
            else:
                # –û—à–∏–±–∫–∞ API
                self.logger.error(f"‚ùå Chat API –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É: {response.status_code}")
                from telegram import Bot
                bot = Bot(token=self.config.token)
                await bot.send_message(
                    chat_id=chat_id,
                    text="üòî –ò–∑–≤–∏–Ω–∏, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑."
                )
                # –û—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä –ø—Ä–∏ –æ—à–∏–±–∫–µ
                self.user_message_buffers[user_id]['messages'] = []
                
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è {user_id}: {e}")
            if user_id in self.user_message_buffers:
                chat_id = self.user_message_buffers[user_id].get('chat_id')
                if chat_id:
                    from telegram import Bot
                    bot = Bot(token=self.config.token)
                    await bot.send_message(
                        chat_id=chat_id,
                        text="üòî –ò–∑–≤–∏–Ω–∏, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑."
                    )
                self.user_message_buffers[user_id]['messages'] = []
    
    def _check_rate_limit(self, user_id: int, action: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç rate limiting"""
        now = datetime.now()
        user_actions = self.rate_limiter[user_id]
        
        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
        cutoff = now - timedelta(minutes=1)
        user_actions[:] = [action_time for action_time in user_actions if action_time > cutoff]
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç—ã
        if action == "message":
            limit = self.config.rate_limit_messages_per_minute
        elif action == "command":
            limit = self.config.rate_limit_commands_per_hour
        else:
            return True
        
        if len(user_actions) >= limit:
            return False
        
        user_actions.append(now)
        return True
    
    async def start(self):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        if not self.application:
            raise RuntimeError("Bot not initialized")
        
        self.logger.info("Starting Telegram bot...")
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞
        commands = []
        for cmd_name, cmd_config in self.config.commands.items():
            if cmd_config.get("enabled", True):
                commands.append(BotCommand(cmd_name, cmd_config["description"]))
        
        await self.application.bot.set_my_commands(commands)
        self.logger.info(f"Bot commands set: {[cmd.command for cmd in commands]}")
        
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–π webhook –ø–µ—Ä–µ–¥ polling, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å 409 Conflict
        try:
            await self.application.bot.delete_webhook(drop_pending_updates=True)
            self.logger.info("Webhook deleted (drop_pending_updates=True)")
        except Exception as e:
            self.logger.warning(f"Failed to delete webhook before polling: {e}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º polling –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ updater –±–µ–∑ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è event loop
        await self.application.initialize()
        await self.application.start()
        await self.application.updater.start_polling(drop_pending_updates=True)
        
        try:
            # –î–µ—Ä–∂–∏–º –±–æ—Ç–∞ –∞–∫—Ç–∏–≤–Ω—ã–º
            while True:
                await asyncio.sleep(1)
        except (KeyboardInterrupt, asyncio.CancelledError):
            self.logger.info("Bot polling interrupted")
        finally:
            await self.application.updater.stop()
            await self.application.stop()
            await self.application.shutdown()
    
    def run(self):
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–π event loop
            try:
                loop = asyncio.get_running_loop()
                # –ï—Å–ª–∏ –µ—Å—Ç—å, —Å–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º loop
                task = loop.create_task(self.start())
                loop.run_until_complete(task)
            except RuntimeError:
                # –ï—Å–ª–∏ –Ω–µ—Ç –∑–∞–ø—É—â–µ–Ω–Ω–æ–≥–æ loop, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
                asyncio.run(self.start())
        except KeyboardInterrupt:
            self.logger.info("Bot stopped by user")
        except Exception as e:
            self.logger.error(f"Bot crashed: {e}")
            raise


def main():
    """–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    try:
        print("ü§ñ –ó–∞–ø—É—Å–∫ Telegram –±–æ—Ç–∞ Agata...")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
        if not os.getenv('TELEGRAM_BOT_TOKEN'):
            print("‚ùå –û—à–∏–±–∫–∞: –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
            print("üí° –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –µ—ë –∫–æ–º–∞–Ω–¥–æ–π:")
            print("   export TELEGRAM_BOT_TOKEN='8181686852:AAH93K4NhfI2oUhhrvLd9MK8Eln1_XsyFi4'")
            return
        
        bot = ProductionTelegramBot()
        bot.run()
        
    except Exception as e:
        print(f"‚ùå Failed to start bot: {e}")
        traceback.print_exc()


if __name__ == "__main__":
    main()